# Keeping Components Pure

#### 순수함수

동일한 입력에 동일한 출력을 하는 함수로 호출되기 전에 존재한 객체나 변수를 변경하지 않는 특징을 갖는다.


## Purity: Components as formulas
> 순수성: 수식으로서의 컴포넌트

리액트에서는 함수는 순수함수라는 개념을 중심으로 설계되었기 때문에 모든 컴포넌트가 순수함수라고 가정한다.  
따라서 *리액트의 컴포넌트는 동일한 입력이 주어졌을 때 항상 동일한 JSX를 반환해야한다.*



## Side Effects: (un)intended consequences
> 사이드 이펙트: 의도하지 (않은) 결과

리액트의 렌더링과정은 항상 순수해야한다. 컴포넌트는 오직 JSX만 반환해야되고 렌더링 전에 있던 객체나 변수를 변경하면 안된다.  
또한 호출하는 횟수에 따라 값이 변경되어도 안된다.


### Strict mode
- 리액트에서는 렌더링하는 동안 `props`, `state`, `context` 이 3가지 입력을 읽을 수 있다.
- 보통 유저가 입력한 값에 따라 변하는 결과에 대한 응답으로 변수 대신에 `state` 를 사용한다.
  - 화면을 업데이트하기위해선 기존 객체를 변이하는 대신 `setState`해야한다.
- Strict mode는 개발환경에서 각 컴포넌트 함수를 두번 호출하여 규칙을 위반하는 컴포넌트를 찾아낼 때 도움이 된다.



### Local mutation: Your component’s little secret
> 지역 변이: 컴포넌트의 작은 비밀

```jsx
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaGathering() {
  let cups = []; // 지역변이
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}
```
- 컴포넌트를 렌더링하는 동안 생성한 변수, 객체를 변경하는 것을 **지역변이**라 하며 렌더링 중에 발생하기 때문에 외부와는 상관이 없다.



### Where you can cause side effects
> 사이드 이펙트를 일으킬 수 있는 곳

- 리액트 렌더링 중에 일어나는 것이 아니라 렌더링 그 이후에 화면업데이트, 애니메이션 시작, 데이터 변경같은 변경을 **사이드이펙트**라 한다.
- 리액트에서 사이드이팩트는 보통 **이벤트 핸들러**에 속한다.
  - 이벤트 핸들러 : 사용자가 어떤 동작을 수행할 때 리액트가 실행하는 함수
  - 렌더링 중에 실행되는 것이 아니기 때문에 순수할 필요가 없는 함수다
- 보통 사이드이팩트에 적합한 이벤트 핸들러를 찾아 렌더링만으로 로직을 표현하고자 노력해야한다.
- But, 모든 옵션을 다 사용해도 적합한 핸들러를 찾지 못한 경우, 컴포넌트에서 `useEffect`를 호출하여 반환된 JSX에 이벤트 핸들러를 첨부할 수도 있다. 이렇게 적용하면 렌더링 이후 사이드이팩트가 허용될 때 리액트가 이 로직을 실행하도록한다. (하지만 이것은 최후의 수단으로 사용해야한다. 왜냐면 `useEffect`는 렌더링 이후에 동작하기 때문에 디버깅이 어려워 최대한 사용을 지양해야하기때문이다.)


### Why does React care about purity?
> 왜 React는 순수성을 중요시할까요?

1. 컴포넌트가 다른 환경에서 실행될 수 있다.
2. 하나의 컴포넌트가 많은 사용자 요청을 처리할 수 있다.
3. 입력이 동일할 경우 렌더링 건너뛰기(**`React.memo`**, 캐싱해도 안전함)를 적용하여 성능을 향상시킬 수 있다.
4. 깊은 컴포넌트 트리를 렌더링 도중 일부 데이터가 변경되면 리액트는 시간을 낭비하지 않고 리렌더링을 시작할 수 있다.
